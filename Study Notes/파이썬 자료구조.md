# ☁️ 파이썬 자료구조
## **리스트 (List)**

- **정의**: 순서가 있는 **변경 가능한** 시퀀스 자료형
- **특징**:
    - 가변 크기: 요소를 추가하거나 제거할 수 있으며, 동적으로 크기를 조절할 수 있음
    - 다양한 자료형 허용: 리스트는 정수, 문자열, 객체 등 다양한 자료형을 포함할 수 있음
    - 인덱싱과 슬라이싱 가능: 인덱스를 통해 요소에 접근하거나, 슬라이싱으로 부분 리스트를 추출할 수 있음
- **시간 복잡도**:
    - 인덱스 접근: O(1)
    - 삽입/삭제: O(n) (중간 요소의 경우)

```python
my_list = [1, 2, 3, 4]
my_list.append(5)     # [1, 2, 3, 4, 5]
my_list[2] = 10       # [1, 2, 10, 4, 5]
```

## **튜플 (Tuple)**

- **정의**: 순서가 있는 **불변** 시퀀스 자료형
- **특징**:
    - 불변성: 한 번 생성된 튜플은 변경할 수 없음
    - 다양한 자료형 허용: 리스트와 마찬가지로 다양한 자료형을 포함할 수 있음
    - 메모리 효율성: 리스트보다 메모리 사용량이 적고, **읽기 전용 데이터에 적합**
- **시간 복잡도**:
    - 인덱스 접근: O(1)

```python
my_tuple = (1, 2, 3)
print(my_tuple[1])  # 2
```

## **딕셔너리 (Dictionary)**

- **정의**: **키와 값의 쌍**으로 이루어진 해시맵 자료형
- **특징**:
    - 키-값 쌍: 고유한 키를 사용해 값을 저장하며, 키를 통해 빠르게 값을 검색할 수 있음
    - 가변성: 값을 추가하거나 삭제할 수 있음. **키는 불변 자료형이어야 하지만, 값은 가변 자료형도 가능함**
    - 순서 보장: 파이썬 3.7부터 삽입 순서가 유지됨
- **시간 복잡도**:
    - 키-값 접근: O(1) (해시맵을 사용)
    - 삽입/삭제: O(1)

```python
my_dict = {'name': 'Alice', 'age': 25}
my_dict['age'] = 26     # {'name': 'Alice', 'age': 26}
print(my_dict['name'])  # Alice
```

## **집합 (Set)**

- **정의**: 고유한 값을 저장하는 변경 가능한 해시 기반 집합 자료형
- **특징**:
    - **중복 허용하지 않음**: 동일한 값은 한 번만 저장됨
    - **순서가 없음**: 순서 없이 저장되므로 인덱싱 불가
    - 합집합, 교집합, 차집합 등 **집합 연산에 적합**
- **시간 복잡도**:
    - 원소 추가/삭제: O(1)
    - 원소 포함 여부 확인: O(1)

```python
my_set = {1, 2, 3}
my_set.add(4)        # {1, 2, 3, 4}
my_set.remove(2)     # {1, 3, 4}
print(3 in my_set)   # True
```

## **데크 (Deque)**

- **정의**: 양방향 큐를 지원하는 자료 구조로, `collections` 모듈의 `deque` 클래스로 구현
- **특징**:
    - 양방향 삽입/삭제: 앞과 뒤에서 모두 삽입 및 삭제가 가능함
    - 리스트보다 효율적인 큐 구현: 리스트의 `append`와 `pop`은 끝에서만 빠르게 작동하나, `deque`는 양쪽에서 O(1) 시간 복잡도로 삽입과 삭제가 가능함
- **시간 복잡도**:
    - 양쪽 끝 삽입/삭제: O(1)

```python
from collections import deque

my_deque = deque([1, 2, 3])
my_deque.append(4)    # deque([1, 2, 3, 4])
my_deque.appendleft(0)  # deque([0, 1, 2, 3, 4])
```

## **힙 (Heap)**

- **정의**: 우선순위 큐를 구현하기 위한 이진 트리 기반 자료 구조로, 최소/최대값을 빠르게 찾는 데 사용됨. 파이썬에서는 `heapq` 모듈로 제공
- **특징**:
    - 최소 힙이 기본: `heapq`는 기본적으로 최소 힙을 제공하여 가장 작은 값이 루트로 정렬됨
    - 효율적인 우선순위 큐: O(log n) 시간 복잡도로 삽입 및 삭제를 수행함
- **시간 복잡도**:
    - 삽입/삭제: O(log n)

```python
import heapq

heap = [3, 2, 5, 1]
heapq.heapify(heap)   # [1, 2, 5, 3] (오름차순 정렬 x, 완전 이진트리의 최소힙 구조)
heapq.heappop(heap)   # 1
```

## **큐 (Queue)**

- **정의**: FIFO(First-In-First-Out) 원칙을 따르는 자료 구조로 `queue` 모듈에서 제공
- **특징**:
    - 선입선출(FIFO): 먼저 들어온 요소가 먼저 나감
    - 멀티스레드 환경에서 자주 사용되며, `queue.Queue`는 스레드 안전성을 보장함
- **시간 복잡도**:
    - 삽입/삭제: O(1)

```python
from queue import Queue

q = Queue()
q.put(1)
q.put(2)
print(q.get())  # 1
```

## 자료구조별 값 추가 및 삭제 요약

| **자료구조** | **형태** | **값 추가 메서드** | **값 삭제 메서드** |
| --- | --- | --- | --- |
| **리스트 (List)** | `[value1, value2, value3]` | `append()`, `insert()`, `extend()` | `remove()`, `pop()`, `clear()` |
| **튜플 (Tuple)** | `(value1, value2, value3)` | 불가능 | 불가능 |
| **딕셔너리 (Dictionary)** | `{'key1': value1, 'key2': value2}` | `dict[key] = value` | `pop()`, `del`, `popitem()`, `clear()` |
| **집합 (Set)** | `{value1, value2, value3}` | `add()`, `update()` | `remove()`, `discard()`, `pop()`, `clear()` |
| **데크 (Deque)** | `deque([value1, value2, value3])` | `append()`, `appendleft()` | `pop()`, `popleft()` |
| **큐 (Queue)** | `Queue()` | `put()` | `get()` |